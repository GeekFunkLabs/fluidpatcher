"""A performance-oriented patch interface for FluidSynth

A Python interface for the FluidSynth software synthesizer that
allows combination of instrument settings, effects, sequences,
midi file players, etc. into performance patches that can be
quickly switched while playing. Patches are written in a rich,
human-readable YAML-based bank file format.

Includes:
- pfluidsynth.py: ctypes bindings to libfluidsynth and wrapper classes
    for FluidSynth's features/functions
- bankfiles.py: extensions to YAML and functions for parsing bank files

Requires:
- yaml
- libfluidsynth
"""

__version__ = '0.9.1'

from pathlib import Path
from copy import deepcopy

from .bankfiles import parseyaml, renderyaml, SFPreset, MidiMessage, RouterRule
from .router import Router
from .pfluidsynth import Synth


class FluidPatcher:
    """An interface for running FluidSynth using patches
    
    Provides methods for:

    - loading/saving the config file and bank files
    - applying/creating/copying/deleting patches
    - directly controlling the Synth by modifying fluidsettings,
      manually adding router rules, and sending MIDI events
    - loading a single soundfont and browsing its presets
    
    Attributes:
      midi_callback: a function that takes a pfluidsynth.Midisignal instance
        as its argument. Will be called when MIDI events are received or
        custom router rules are triggered. This allows scripts to define
        and handle their own custom router rules and/or monitor incoming events.    
        MidiSignal events have `type`, `chan`, `par1`, and `par2` events matching
        the triggering event. MidiSignals generated by rules have extra attributes
        corresponding to the rule parameters, plus a `val` attribute that is the
        result of parameter routing. Rules with a `patch` parameter will be modified
        by FluidPatcher so that the `patch` attribute corresponds to the patch index.
        If `patch` is -1, `val` is set to the patch increment.
    
    See the documentation for information on bank file format.
    """

    def __init__(self, cfgfile, **fluidsettings):
        """Creates FluidPatcher and starts FluidSynth
        
        Starts fluidsynth using settings found in yaml-formatted `cfgfile`.
        Settings passed via `fluidsettings` will override those in config file.
        See https://www.fluidsynth.org/api/fluidsettings.xml for a
        full list and explanation of settings. See documentation
        for config file format.
        
        Args:
          cfgfile: Path object pointing to config file
          fluidsettings: dictionary of additional fluidsettings
        """
        
        self.cfgfile = Path(cfgfile)
        self.cfg = parseyaml(self.cfgfile.read_text())
        self.bankdir = Path(self.cfg.get('bankdir', 'banks')).resolve()
        self.sfdir = Path(self.cfg.get('soundfontdir', self.bankdir / '../sf2')).resolve()
        self.mfilesdir = Path(self.cfg.get('mfilesdir', self.bankdir / '../midi')).resolve()
        self.plugindir = Path(self.cfg.get('plugindir', '')).resolve()
        self.synth = Synth(**{self.cfg.get('fluidsettings', {}) | fluidsettings})
        self.router = Router(self.synth)
        self.router.midi_callback = self._midisignal_handler
        self.soundfonts = {}
        self.max_channels = self.fluidsetting_get('synth.midi-channels')
        self.patchcord = {'patchcordxxx': {'lib': self.plugindir / 'patchcord', 'audio': 'mono'}}
        self.midi_callback = None

    @property
    def currentbank(self):
        """a Path object pointing to the current bank file"""
        return Path(self.cfg['currentbank']) if 'currentbank' in self.cfg else ''

    def update_config(self):
        """Write current configuration stored in `cfg` to file.
        """
        self.cfgfile.write_text(renderyaml(self.cfg))

    def load_bank(self, bankfile='', raw=''):
        """Load a bank from a file or from raw yaml text

        Parses a yaml stream from a string or file and stores as a
        nested collection of dict and list objects. The top-level
        dict must have at minimum a `patches` element or an error
        is raised. If loaded from a file successfully, that file
        is set as `currentbank` in the config - call update_config()
        to make it persistent.

        Upon loading, resets the synth, loads all necessary soundfonts,
        and applies settings in the `init` element. Returns the yaml stream
        as a string. If called with no arguments, resets the synth and
        restores the current bank from memory.

        Args:
          bankfile: bank file to load, absolute or relative to `bankdir`
          raw: string to parse directly

        Returns: yaml stream that was loaded
        """
        if bankfile:
            raw = (self.bankdir / bankfile).read_text()
            self.cfg['currentbank'] = Path(bankfile).as_posix()
        self.bank = Bank(parseyaml(raw))

        self.synth.reset()        
        for file in set(self.soundfonts) - self.bank.soundfonts:
            self.synth.unload_soundfont(self.soundfonts[file])
            del self.soundfonts[file]
        for file in self.bank.soundfonts - set(self.soundfonts):
            self.soundfonts[file] = self.synth.load_soundfont(self.sfdir / file):
        for opt, val in (_SYNTH_DEFAULTS |
                         self.cfg.get('fluidsettings', {}) |
                         self.bank.get('init', {}).get('fluidsettings', {})).items():
            self.fluidsetting_set(opt, val)
        for msg in self.bank.get('init', {}).get('messages', []):
            self.send_event(msg)
        return raw

    def save_bank(self, bankfile, raw=''):
        """Save a bank file
        
        Saves the current bank in memory to `bankfile` after rendering it as
        a yaml stream. If `raw` is provided, it is parsed as the new bank and
        its exact contents are written to the file.

        Args:
          bankfile: file to save, absolute or relative to `bankdir`
          raw: exact text to save
        """
        if raw:
            bank = parseyaml(raw)
            self.bank = bank
        else:
            raw = renderyaml(self.bank)
        (self.bankdir / bankfile).write_text(raw)
        self.cfg['currentbank'] = Path(bankfile).as_posix()

    def apply_patch(self, patch):
        """Select a patch and apply its settings

        Read the settings for the patch specified by index or name and combine
        them with bank-level settings. Select presets on specified channels and
        unsets others, clears router rules and applies new ones, activates 
        players and effects and deactivates unused ones, send messages, and
        applies fluidsettings. Patch settings are applied after bank settings.
        If the specified patch isn't found, only bank settings are applied.

        Args:
          patch: patch index or name
        """
        for ch in range(1, self.max_channels + 1):
            if p := self.bank[patch][ch]:
                self.synth.program_select(ch, self.sfdir / p.sfont, p.bank, p.prog)
            else:
                self.synth.program_unset(ch)
        # fluidsettings
        for opt, val in self.bank[patch]['fluidsettings'].items():
            self.fluidsetting_set(opt, val)
        # sequencers, arpeggiators, midiplayers
        for name in self.synth.players:
            if name not in [*self.bank[patch]['sequencers'],
                            *self.bank[patch]['arpeggiators'],
                            *self.bank[patch]['midiplayers']]:
                self.synth.player_remove(name)
        for name, seq in self.bank[patch]['sequencers'].items():
            self.synth.sequencer_add(name, **seq)
        for name, arp in self.bank[patch]['arpeggiators'].items():
            self.synth.arpeggiator_add(name, **arp)
        for name, midi in self.bank[patch]['midiplayers'].items():
            self.synth.midiplayer_add(name, **midi)
        # ladspa effects
        if self.synth.ladspafx != self.bank[patch]['ladspafx']:
            self.synth.fxchain_clear()
            for name, fx in (self.bank[patch]['ladspafx'] | self.patchcord).items():
                self.synth.fxchain_add(name, **fx)
            if self.synth.ladspafx:
                self.synth.fxchain_connect()
        # router rules -- invert b/c fluidsynth applies rules last-first
        self.synth.router_default()
        for rule in self.bank[patch]['router_rules'][::-1]:
            rule.add(self.router.addrule)
        # midi messages
        for msg in self.bank[patch]['messages']:
            self.send_event(msg)

    def update_patch(self, patch):
        """Update the current patch

        Instruments and controller values can be changed by program change (PC)
        and continuous controller (CC) messages, but these will not persist
        in the patch unless this function is called. Settings can be saved to
        a new patch by first calling add_patch(), then update_patch() on the
        new patch. The bank file must be saved for updated patches to become
        permanent.

        Args:
          patch: index or name of the patch to update
        """
        messages = self.bank[patch]['messages']
        for channel in range(1, self.max_channels + 1):
            for cc, default in enumerate(_CC_DEFAULTS):
                val = self.synth.get_cc(channel, cc)
                if val == default or default < 0 :
                    continue
                self.bank[patch]['messages'] += MidiMessage('cc', channel, cc, val)
            info = self.synth.program_info(channel)
            if not info:
                patch.pop(channel, None)
                continue
            sfont, bank, prog = info
            sfrel = Path(sfont).relative_to(self.sfdir).as_posix()
            patch[channel] = SFPreset(sfrel, bank, prog)
        if messages:
            patch['messages'] = list(messages)

    def delete_patch(self, patch):
        """Delete a patch from the bank in memory

        Bank file must be saved for deletion to be permanent

        Args:
          patch: index or name of the patch to delete
        """
        del self.bank[patch]
        for file in set(self.soundfonts) - self.bank.soundfonts
            self.synth.unload_soundfont(self.soundfonts[file])
            del self.soundfonts[file]

    def select_preset(self, chan, file, bank, prog):
        for file in set(self.soundfonts) - self.bank.soundfonts - {file}
            self.synth.unload_soundfont(self.soundfonts[file])
            del self.soundfonts[file]
        if file not in self.soundfonts:
            sfont = self.synth.load_soundfont(self.sfdir / file):
            self.soundfonts[file] = sfont
        self.fsynth.program_select(chan, sfont, bank, prog)

    def fluidsetting_get(self, opt):
        """Get the current value of a FluidSynth setting

        Args:
          opt: setting name

        Returns: the setting's current value as float, int, or str
        """
        return self.synth.get_setting(opt)

    def fluidsetting_set(self, opt, val, patch=None):
        """Change a FluidSynth setting

        Modifies a FluidSynth setting. Settings without a "synth." prefix
        are ignored. If `patch` is provided, these settings are also added to
        the current bank in memory at bank level, and any conflicting
        settings are removed from the specified patch. The bank file
        must be saved for the changes to become permanent.

        Args:
          opt: setting name
          val: new value to set, type depends on setting
          patch: patch name or index
        """
        if not opt.startswith('synth.'): return
        self.synth.setting(opt, val)
        if patch != None:
            if 'fluidsettings' not in self.bank:
                self.bank['fluidsettings'] = {}
            self.bank['fluidsettings'][opt] = val
            patch = self._resolve_patch(patch)
            if 'fluidsettings' in patch and opt in patch['fluidsettings']:
                del patch['fluidsettings'][opt]

    def add_router_rule(self, **pars):
        """Add a router rule to the Synth

        Directly add a router rule to the Synth. This rule will be added
        after the current bank- and patch-level rules. The rule is not
        saved to the bank, and will disappear if a patch is applied
        or the synth is reset.

        Returns:
          pars: router rule as a set of key=value pairs
        """
        RouterRule(**pars).add(self.router.addrule)

    def send_event(self, msg=None, type='note', chan=1, num=0, val=0):
        """Send a MIDI event to the Synth

        Sends a MidiMessage, or constructs one from a bank file-styled string
        (<type>:<channel>:<par1>:<par2>) or keywords and sends it
        to the synth.

        Args:
          msg: MidiMessage instance or string
          type: event type as string
          chan: MIDI channel
          par1: first parameter, integer or note name
          par2: second parameter for valid types
        """
        if isinstance(msg, str):
            msg = parseyaml(msg)
        elif msg == None:
            msg = MidiMessage(type, chan, num, val)
        self.synth.send_event(msg)

    def _midisignal_handler(self, sig):
        if 'patch' in sig:
            if sig.patch in self.patches:
                sig.patch = self.patches.index(sig.patch)
            elif sig.patch == 'select':
                sig.patch = int(sig.val - 1) % len(self.patches)
            elif str(sig.patch)[-1] in '+-':
                sig.val = int(sig.patch[-1] + sig.patch[:-1])
                sig.patch = -1
            elif isinstance(sig.patch, int):
                sig.patch -= 1
            else:
                sig.patch = -1
                sig.val = 0
        if self.midi_callback: self.midi_callback(sig)


class Bank:

    def __init__(self, bank):
        self.bank = data
        
    def __getitem__(self, name):
        patches = self.bank.get('patches', {})
        if name in patches:
            patch = patches[name]
        elif isinstance(name, int):
            patch = patches[name % len(patches)]
        else:
            patch = {}
        return Patch(self.bank, patch)

    def __setitem__(self, name, patch):
        if 'patches' in self.bank:
            self.bank['patches'] = {name: patch}
        else:
            self.bank['patches'][name] = patch
    
    def __delitem__(self, name):
        del self.bank['patches'][name]
        if self.bank['patches'] == {}:
            del self.bank['patches']

    def __len__(self):
        return len(self.bank.get('patches', {}))

    @property
    def patches(self):
        """List of patch names"""
        return list(self.bank.get('patches', {}))
        
    @property
    def soundfonts(self):
        """Set of all soundfonts used by patches"""
        sfonts = set()
        for zone in self.bank, *self.bank.get('patches', {}).values():
            for object in zone:
                if isinstance(object, int):
                    sfonts.add(zone[object].sfont)
        return sfonts


class Patch:

    def __init__(self, bank, patch):
        self.bank = bank
        self.patch = patch
        
    def __getitem__(self, name):
        if isinstance(name, int):
            return self.patch.get(name) or self.bank.get(name)
        elif name in 'router_rules', 'messages':
            return self.bank.get(name, []) + self.patch.get(name, [])
        else:
            return self.bank.get(name, {}) | self.patch.get(name, {})

    def __setitem__(self, name, item):
        self.patch[name] = item


_CC_DEFAULTS = [0] * 120
_CC_DEFAULTS[0] = -1             # bank select
_CC_DEFAULTS[7] = 100            # volume
_CC_DEFAULTS[8] = 64             # balance
_CC_DEFAULTS[10] = 64            # pan
_CC_DEFAULTS[11] = 127           # expression
_CC_DEFAULTS[32] = -1            # bank select LSB
_CC_DEFAULTS[43] = 127           # expression LSB
_CC_DEFAULTS[70:80] = [64] * 10  # sound controls
_CC_DEFAULTS[84] = 255           # portamento control
_CC_DEFAULTS[96:102] = [-1] * 6  # RPN/NRPN controls

_SYNTH_DEFAULTS = {'synth.chorus.active': 1, 'synth.reverb.active': 1,
                  'synth.chorus.depth': 8.0, 'synth.chorus.level': 2.0,
                  'synth.chorus.nr': 3, 'synth.chorus.speed': 0.3,
                  'synth.reverb.damp': 0.0, 'synth.reverb.level': 0.9,
                  'synth.reverb.room-size': 0.2, 'synth.reverb.width': 0.5,
                  'synth.gain': 0.2}
