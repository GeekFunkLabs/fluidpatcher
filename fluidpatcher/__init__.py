"""A performance-oriented patch interface for FluidSynth

A Python interface for the FluidSynth software synthesizer that
allows combination of instrument settings, effects, sequences,
midi file players, etc. into performance patches that can be
quickly switched while playing. Patches are written in a rich,
human-readable YAML-based bank file format.

Includes:
- pfluidsynth.py: ctypes bindings to libfluidsynth and wrapper classes
    for FluidSynth's features/functions
- bankfiles.py: extensions to YAML and functions for parsing bank files

Requires:
- yaml
- libfluidsynth
"""

__version__ = '0.9.1'

from pathlib import Path
from copy import deepcopy

from .bankfiles import parseyaml, renderyaml, SFPreset, MidiMessage, RouterRule
from .router import Router
from .pfluidsynth import Synth


class FluidPatcher:
    """An interface for running FluidSynth using patches
    
    Provides methods for:

    - loading/saving the config file and bank files
    - applying/creating/copying/deleting patches
    - directly controlling the Synth by modifying fluidsettings,
      manually adding router rules, and sending MIDI events
    - loading a single soundfont and browsing its presets
    
    Attributes:
      midi_callback: a function that takes a pfluidsynth.Midisignal instance
        as its argument. Will be called when MIDI events are received or
        custom router rules are triggered. This allows scripts to define
        and handle their own custom router rules and/or monitor incoming events.    
        MidiSignal events have `type`, `chan`, `par1`, and `par2` events matching
        the triggering event. MidiSignals generated by rules have extra attributes
        corresponding to the rule parameters, plus a `val` attribute that is the
        result of parameter routing. Rules with a `patch` parameter will be modified
        by FluidPatcher so that the `patch` attribute corresponds to the patch index.
        If `patch` is -1, `val` is set to the patch increment.
    
    See the documentation for information on bank file format.
    """

    def __init__(self, cfgfile, **fluidsettings):
        """Creates FluidPatcher and starts FluidSynth
        
        Starts fluidsynth using settings found in yaml-formatted `cfgfile`.
        Settings passed via `fluidsettings` will override those in config file.
        See https://www.fluidsynth.org/api/fluidsettings.xml for a
        full list and explanation of settings. See documentation
        for config file format.
        
        Args:
          cfgfile: Path object pointing to config file
          fluidsettings: dictionary of additional fluidsettings
        """
        
        self.cfg = Config(cfgfile)
        self.router = Router()
        self.synth = Synth(self.router.handle_midi, **self.cfg.fluidsettings | fluidsettings)
        self.router.synth = self.synth
        self.router.midi_callback = self._midisignal_handler
        self.midi_callback = None
        self.soundfonts = {}
        self._patchcord = {'_patchcord': {'lib': self.cfg.pluginpath / 'patchcord'}}

    def load_bank(self, bankfile='', raw=''):
        """Load a bank from a file or from raw yaml text

        Parses a yaml stream from a string or file and stores as a
        nested collection of dict and list objects. The top-level
        dict must have at minimum a `patches` element or an error
        is raised. If loaded from a file successfully, that file
        is set as `currentbank` in the config - call update_config()
        to make it persistent.

        Upon loading, resets the synth, loads all necessary soundfonts,
        and applies settings in the `init` element. Returns the yaml stream
        as a string. If called with no arguments, resets the synth and
        restores the current bank from memory.

        Args:
          bankfile: bank file to load, absolute or relative to `bankdir`
          raw: string to parse directly

        Returns: yaml stream that was loaded
        """
        if bankfile:
            raw = (self.cfg.bankpath / bankfile).read_text()
            self.cfg.bankfile = bankfile
        self.bank = Bank(parseyaml(raw))

        self.synth.reset()
        names = self.bank.root.get('names', {})
        for zone in self.bank:
            for midi in zone.get('midiplayers', {}).values():
                midi.file = self.mfilesdir / midi.file
            for fx in zone.get('ladspafx', {}).values():
                fx.lib = self.plugindir / fx.lib
            for rule in zone.get('router_rules', []):
                rule.sub(names):
            for msg in zone.get('messages', []):
                msg.sub(names)
        init = self.bank.root.get('init', {})
        for name, val in (_SYNTH_DEFAULTS | init.get('fluidsettings', {})).items():
            self.synth[name] = val
        for msg in init.get('messages', []):
            msg.sub(names)
            self.send_event(msg)
        return raw

    def save_bank(self, bankfile, raw=''):
        """Save a bank file
        
        Saves the current bank in memory to `bankfile` after rendering it as
        a yaml stream. If `raw` is provided, it is parsed as the new bank and
        its exact contents are written to the file.

        Args:
          bankfile: file to save, absolute or relative to `bankdir`
          raw: exact text to save
        """
        if raw:
            self.bank = Bank(parseyaml(raw))
        else:
            raw = renderyaml(self.bank.bank)
        (self.cfg.bankpath / bankfile).write_text(raw)
        self.cfg.bankfile = bankfile

    def apply_patch(self, patch):
        """Apply the settings in a patch to the synth

        Read the settings for the patch specified by index or name and combine
        them with bank-level settings. Select presets on specified channels and
        unsets others, clears router rules and applies new ones, activates 
        players and effects and deactivates unused ones, send messages, and
        applies fluidsettings. Patch settings are applied after bank settings.
        If the specified patch isn't found, only bank settings are applied.

        Args:
          patch: patch index or name
        """
        # load all needed soundfonts at once to speed up patches
        # free memory of unneeded soundfonts
        for file in set(self.soundfonts) - self.bank.soundfonts
            self.synth.unload_soundfont(self.soundfonts[file])
            del self.soundfonts[file]
        for file in self.bank.soundfonts - set(self.soundfonts):
            self.soundfonts[file] = self.synth.load_soundfont(self.sfpath / file):
        # select presets
        for channel in range(1, self.synth['synth.midi-channels'] + 1):
            if p := self.bank[patch][channel]:
                self.synth.program_select(channel, self.soundfonts[p.file], p.bank, p.prog)
            else:
                self.synth.program_unset(channel)
        # fluidsettings
        for name, val in self.bank[patch]['fluidsettings'].items():
            self.synth[opt] = val
        # sequencers, arpeggiators, midiplayers
        for name in self.synth.players:
            if name not in [*self.bank[patch]['sequencers'],
                            *self.bank[patch]['arpeggiators'],
                            *self.bank[patch]['midiplayers']]:
                self.synth.player_remove(name)
        for name, seq in self.bank[patch]['sequencers'].items():
            self.synth.sequencer_add(name, **seq)
        for name, arp in self.bank[patch]['arpeggiators'].items():
            self.synth.arpeggiator_add(name, **arp)
        for name, midi in self.bank[patch]['midiplayers'].items():
            midi['file'] = self.cfg.midipath / midi['file']
            self.synth.midiplayer_add(name, **midi)
        # ladspa effects
        if self.synth.ladspafx != self.bank[patch]['ladspafx']:
            self.synth.fxchain_clear()
            for name, fx in (self.bank[patch]['ladspafx'] | self._patchcord).items():
                fx['lib'] = self.cfg.pluginpath / fx['lib']
                self.synth.fxchain_add(name, **fx)
            if self.synth.ladspafx:
                self.synth.fxchain_connect()
        # router rules -- invert b/c fluidsynth applies rules last-first
        self.router.reset()
        for rule in self.bank[patch]['router_rules']:
            rule.add(self.router.add)
        # midi messages
        for msg in self.bank[patch]['messages']:
            self.synth.send_event(msg)

    def update_patch(self, patch):
        """Update a patch from the current synth state

        Instruments and controller values can be changed by program change (PC)
        and continuous controller (CC) messages, but these will not persist
        in the patch unless this function is called. Settings can be saved to
        a new patch by first calling add_patch(), then update_patch() on the
        new patch. The bank file must be saved for updated patches to become
        permanent.

        Args:
          patch: index or name of the patch to update
        """
        self.bank.patches[patch]['messages'] = []
        sfonts = {self.soundfonts[file].id, file for file in self.soundfonts}
        for channel in range(1, self.synth['synth.midi-channels'] + 1):
            for cc, default in enumerate(_CC_DEFAULTS):
                val = self.synth.get_cc(channel, cc)
                if val != default and default != -1 :
                    self.bank.patches[patch]['messages'] += [MidiMessage('cc', channel, cc, val)]
            id, bank, prog = self.synth.program_info(channel)
            if id not in sfonts:
                del self.bank[patch][channel]
            else:
                patch[channel] = SFPreset(sfonts[id], bank, prog)

    def copy_patch(self, src, dest):
        self.bank.patches[dest] = deepcopy(self.bank.patches[src])

    def delete_patch(self, patch):
        """Delete a patch from the bank in memory

        Bank file must be saved for deletion to be permanent

        Args:
          patch: index or name of the patch to delete
        """
        del self.bank[patch]
        for file in set(self.soundfonts) - self.bank.soundfonts
            self.synth.unload_soundfont(self.soundfonts[file])
            del self.soundfonts[file]

    def add_router_rule(self, **pars):
        """Add a router rule to the Synth

        Directly add a router rule to the Synth. This rule will be added
        after the current bank- and patch-level rules. The rule is not
        saved to the bank, and will disappear if a patch is applied
        or the synth is reset.

        Args:
          pars: router rule as a set of key=value pairs
        """
        RouterRule(**pars).add(self.router.addrule)

    def send_event(self, msg=None, type='note', chan=1, num=0, val=0):
        """Send a MIDI event to the Synth

        Sends a MidiMessage, or constructs one from a bank file-styled string
        (<type>:<channel>:<par1>:<par2>) or keywords and sends it
        to the synth.

        Args:
          msg: MidiMessage instance or string
          type: event type as string
          chan: MIDI channel
          par1: first parameter, integer or note name
          par2: second parameter for valid types
        """
        if isinstance(msg, str):
            msg = parseyaml(msg)
        elif msg == None:
            msg = MidiMessage(type, chan, num, val)
        self.synth.send_event(msg)

    def fluidsetting(self, name):
        return self.synth[name]
        
    def fluidsetting_set(self, name, val):
        if not name.startswith('synth.'):
            return
        self.synth[name] = val

    def _midisignal_handler(self, sig):
        if 'patch' in sig:
            if sig.patch in self.patches:
                sig.patch = self.patches.index(sig.patch)
            elif sig.patch == 'select':
                sig.patch = int(sig.val - 1) % len(self.patches)
            elif str(sig.patch)[-1] in '+-':
                sig.val = int(sig.patch[-1] + sig.patch[:-1])
                sig.patch = -1
            elif isinstance(sig.patch, int):
                sig.patch -= 1
            else:
                sig.patch = -1
                sig.val = 0
        if self.midi_callback: self.midi_callback(sig)


class Config:

    def __init__(self, file):
        self.file = Path(file)
        self.cfg = parseyaml(file.read_text())
        self.bankpath = Path(self.cfg.get('bankpath', 'banks')).resolve()
        self.sfpath = Path(self.cfg.get('sfpath', self.bankpath / '../sf2')).resolve()
        self.midipath = Path(self.cfg.get('midipath', self.bankpath / '../midi')).resolve()
        self.pluginpath = Path(self.cfg.get('pluginpath', '')).resolve()
        self.fluidsettings = self.cfg.get('fluidsettings', {})
        
    @property
    def bankfile(self):
        return Path(self.cfg['bankfile']) if 'bankfile' in self.cfg else ''

    @bankfile.setter
    def bankfile(self, file):
        self.cfg['bankfile'] = Path(file).as_posix()
        self.file.write_text(renderyaml(self.cfg))


class Bank:

    def __init__(self, data):
        self.patches = data.get('patches', {})
        self.root = data
        
    def __getitem__(self, name):
        if name in self.patches:
            patch = self.patches[name]
        elif isinstance(name, int):
            patch = self.patches[name % len(patches)]
        return Patch(self.root, patch)

    def __len__(self):
        return len(self.patches)

    def __iter__(self):
        return iter([self.root, *self.patches.values()])

    @property
    def soundfonts(self):
        """Set of all soundfonts used by patches"""
        sfonts = set()
        for patch in self.patches:
            for item in self[patch]:
                if isinstance(item, int):
                    sfonts.add(patch[item].file)
        return sfonts

    @property
    def bank(self):
        return self.root | ({'patches': self.patches} if self.patches else {})


class Patch:

    def __init__(self, root, patch):
        self.patch = patch
        self.root = root
        
    def __getitem__(self, name):
        if isinstance(name, int):
            return self.patch.get(name) or self.root.get(name)
        elif name in 'router_rules', 'messages':
            return self.root.get(name, []) + self.patch.get(name, [])
        else:
            return self.root.get(name, {}) | self.patch.get(name, {})

    def __setitem__(self, name, item):
        self.patch[name] = item


_CC_DEFAULTS = [0] * 120
_CC_DEFAULTS[0] = -1             # bank select
_CC_DEFAULTS[7] = 100            # volume
_CC_DEFAULTS[8] = 64             # balance
_CC_DEFAULTS[10] = 64            # pan
_CC_DEFAULTS[11] = 127           # expression
_CC_DEFAULTS[32] = -1            # bank select LSB
_CC_DEFAULTS[43] = 127           # expression LSB
_CC_DEFAULTS[70:80] = [64] * 10  # sound controls
_CC_DEFAULTS[84] = 255           # portamento control
_CC_DEFAULTS[96:102] = [-1] * 6  # RPN/NRPN controls

_SYNTH_DEFAULTS = {'synth.chorus.active': 1, 'synth.reverb.active': 1,
                  'synth.chorus.depth': 8.0, 'synth.chorus.level': 2.0,
                  'synth.chorus.nr': 3, 'synth.chorus.speed': 0.3,
                  'synth.reverb.damp': 0.0, 'synth.reverb.level': 0.9,
                  'synth.reverb.room-size': 0.2, 'synth.reverb.width': 0.5,
                  'synth.gain': 0.2}
